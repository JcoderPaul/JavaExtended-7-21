******* Метод *.merge() *******

Реализация: default V merge(K key,
                            V value,
                            BiFunction<? super V,? super V,? extends V> remappingFunction)

Если указанный ключ еще не связан со значением или связан с нулевым значением,
метод связывает его с данным ненулевым значением. В противном случае заменяет
связанное значение результатами данной функции переназначения или удаляет, если
результат равен нулю. Этот метод может быть полезен при объединении (коллекций)
нескольких сопоставленных значений для ключа.

Например, чтобы создать или добавить к String msg сопоставленное значение:
----------------------------------------------------------------------------
map.merge(key, msg, String::concat)
----------------------------------------------------------------------------

Если необходимо объединить значение в Map с другим под таким же ключом:
----------------------------------------------------------------------------
Map<String, String> map = new HashMap<>();
map.put("question", "Vasya");
map.merge("question", " Bukin", (oldVal, newVal) -> oldVal + newVal);

System.out.println(map.get("question"));
// На экране: Vasya Bukin
----------------------------------------------------------------------------
При этом, если такой пары в Map нет, она будет создана
----------------------------------------------------------------------------
Map<String, String> map = new HashMap<>();

map.merge("question", "Right answer!", (oldVal, newVal) -> oldVal + newVal);

System.out.println(map.get("question"));
// На экране: Right answer!
----------------------------------------------------------------------------

Если функция возвращает null, сопоставление удаляется. Если сама функция выдает
(unchecked) исключение, исключение выбрасывается повторно, а текущее сопоставление
остается неизменным.

Требования к реализации: Реализация по умолчанию эквивалентна выполнению следующих
шагов для текущей Map с последующим возвратом текущего значения или нулевого значения,
если оно отсутствует:
----------------------------------------------------------------------------
 V oldValue = map.get(key);
 V newValue = (oldValue == null) ? value :
              remappingFunction.apply(oldValue, value);
 if (newValue == null)
     map.remove(key);
 else
     map.put(key, newValue);
----------------------------------------------------------------------------

Реализация метода по умолчанию не дает никаких гарантий в отношении свойств
синхронизации или атомарности этого метода. Любая реализация, предоставляющая
гарантии атомарности, должна переопределить этот метод и задокументировать
его свойства параллелизма.

В частности, все реализации подинтерфейса ConcurrentMap должны документировать,
применяется ли функция один раз атомарно только в том случае, если значение
отсутствует.

Параметры:
- key - ключ, с которым результирующее значение должно быть связано;
- value - ненулевое значение, которое будет объединено с существующим значением,
          связанным с ключом, или, если с ключом не связано существующее значение
          или нулевое значение, будет связано с ключом;
- remappingFunction - функция для пересчета значения, если оно присутствует;

Возвращает: новое значение, связанное с указанным ключом, или null, если с ключом
            не связано никакого значения

Исключения:
- UnsupportedOperationException - если операция размещения не поддерживается текущим
                                  Map (необязательно);
- ClassCastException - если класс указанного ключа или значения препятствует его
                       сохранению в этом Map (необязательно);
- NullPointerException - если указанный ключ имеет значение null и текущий Map не
                         поддерживает нулевые ключи или значение или remappingFunction
                         равно null.

Метод доступен в Java с версии: 1.8

---------------------------------------------------------------------------------------
Более подробно см. - https://docs.oracle.com/javase/8/docs/api/java/util/Map.html
---------------------------------------------------------------------------------------
